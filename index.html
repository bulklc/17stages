<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Monomyth Comparison</title>
    <link rel="icon" type="image/png" href="favicon.png" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: #f8f4ed;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 0;
        color: #333;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vh;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
      }

      svg {
        width: 100%;
        height: 100%;
      }

      .stage {
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .stage circle.stage-bg {
        fill: #fff;
        stroke: #333;
        stroke-width: 2;
        transition: all 0.3s ease;
      }

      .stage:hover circle.stage-bg {
        fill: #ffd700;
        stroke: #ffd700; /* This should already be gold */
        stroke-width: 4;
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
      }

      .stage[data-ring]:hover circle.stage-bg {
        fill: #ffd700;
        stroke: #ffd700 !important; /* Important to override inline style */
        stroke-width: 4;
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8));
      }

      .stage .stage-icon {
        pointer-events: none;
      }

      .stage text {
        pointer-events: none;
        fill: #333;
        font-size: 10px;
        font-weight: 600;
        text-anchor: middle;
        dominant-baseline: middle;
      }

      .act-segment {
        fill: none;
        stroke-width: 10;
        opacity: 0.6;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .act-segment:hover {
        opacity: 1;
        stroke-width: 14;
        filter: drop-shadow(0 0 10px currentColor);
      }

      .center-circle {
        fill: rgba(255, 255, 255, 0.95);
        stroke: rgba(100, 100, 100, 0.3);
        stroke-width: 2;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .center-circle:hover {
        fill: rgba(255, 255, 255, 1);
        stroke: rgba(255, 215, 0, 0.8);
        stroke-width: 3;
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.5));
      }

      .center-text {
        fill: #333;
        font-size: 16px;
        font-weight: bold;
        text-anchor: middle;
        dominant-baseline: middle;
        pointer-events: none;
      }

      .hover-tooltip {
        position: fixed;
        background: rgba(0, 0, 0, 0.95);
        padding: 20px;
        border-radius: 10px;
        max-width: 450px;
        pointer-events: none;
        z-index: 999;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
        border: 2px solid #ffd700;
      }

      /* Mobile responsiveness for tooltip */
      @media (max-width: 768px) {
        .hover-tooltip {
          max-width: 85vw;
          padding: 15px;
          max-height: 70vh;
          overflow-y: auto;
          left: 50% !important;
          top: 50% !important;
          transform: translate(-50%, -50%);
        }

        .hover-tooltip h3 {
          font-size: 1.1em;
        }

        .hover-tooltip .tooltip-meta {
          font-size: 0.75em;
        }

        .hover-tooltip p {
          font-size: 0.85em;
        }

        .tooltip-icon-large {
          margin-bottom: 10px;
        }

        .tooltip-icon-large img {
          max-height: 30vh;
          object-fit: contain;
        }
      }

      @media (max-width: 480px) {
        .hover-tooltip {
          max-width: 90vw;
          padding: 12px;
          max-height: 75vh;
          left: 50% !important;
          top: 50% !important;
          transform: translate(-50%, -50%);
        }

        .hover-tooltip h3 {
          font-size: 1em;
          margin-bottom: 6px;
        }

        .hover-tooltip .tooltip-meta {
          font-size: 0.7em;
          margin-bottom: 8px;
        }

        .hover-tooltip p {
          font-size: 0.8em;
          line-height: 1.4;
        }

        .tooltip-icon-large img {
          max-height: 25vh;
          object-fit: contain;
        }
      }

      .hover-tooltip.visible {
        opacity: 1;
      }

      .tooltip-icon-large {
        width: 100%;
        margin-bottom: 15px;
        display: none;
      }

      .tooltip-icon-large.visible {
        display: block;
      }

      .tooltip-icon-large img {
        width: 100%;
        height: auto;
        border-radius: 8px;
        border: 2px solid #ffd700;
      }

      .hover-tooltip h3 {
        color: #ffd700;
        margin-bottom: 8px;
        font-size: 1.3em;
      }

      .hover-tooltip .tooltip-meta {
        color: #aaa;
        margin-bottom: 10px;
        font-size: 0.85em;
      }

      .hover-tooltip p {
        line-height: 1.5;
        color: #ddd;
        font-size: 0.95em;
      }

      /* Direction arrows along the main circle */
      .direction-arrows {
        pointer-events: none;
      }
      .circle-arrow {
        fill: none;
        stroke: #666;
        stroke-width: 2;
        opacity: 0.5;
      }

      /* Radial connection lines */
      .connection-lines {
        pointer-events: none;
      }

      .connection-line {
        stroke: #666666;
        stroke-width: 2;
        stroke-dasharray: 3, 3;
        opacity: 0.5;
        transition: all 0.2s ease;
      }

      .connection-line.visible {
        stroke: #ffd700;
        stroke-width: 5;
        stroke-dasharray: none;
        opacity: 0.9;
      }

      /* Story selection modal */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .modal.visible {
        display: flex;
      }

      .modal-content {
        background: white;
        padding: 30px;
        border-radius: 15px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      .modal-content h2 {
        margin-bottom: 10px;
        color: #333;
      }

      .modal-subtitle {
        color: #666;
        margin-bottom: 20px;
        font-size: 0.95em;
      }

      .story-option {
        padding: 15px;
        margin: 10px 0;
        border: 2px solid #ddd;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .story-option:hover {
        border-color: #ffd700;
        background: #fffef5;
        transform: translateX(5px);
      }

      .story-option.selected {
        border-color: #ffd700;
        background: #fff9e6;
      }

      .story-checkbox {
        width: 20px;
        height: 20px;
        border: 2px solid #666;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .story-option.selected .story-checkbox {
        background: #ffd700;
        border-color: #ffd700;
      }

      .story-option.selected .story-checkbox::after {
        content: "✓";
        color: white;
        font-weight: bold;
      }

      .story-name {
        font-weight: 600;
        color: #333;
      }

      .modal-buttons {
        margin-top: 20px;
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .modal-button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .modal-button.cancel {
        background: #ddd;
        color: #666;
      }

      .modal-button.cancel:hover {
        background: #ccc;
      }

      .modal-button.apply {
        background: #ffd700;
        color: #333;
      }

      .modal-button.apply:hover {
        background: #ffed4e;
      }

      .selection-count {
        color: #999;
        font-size: 0.9em;
        margin-top: 10px;
      }

      /* Loading overlay */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
      }

      .loading-overlay.visible {
        display: flex;
      }

      .loading-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .loading-spinner {
        width: 80px;
        height: 80px;
        position: relative;
        animation: rotate 2s linear infinite;
      }

      .loading-spinner svg {
        width: 100%;
        height: 100%;
        transform: rotate(-90deg);
      }

      @keyframes rotate {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        color: #ffd700;
        font-size: 18px;
        font-weight: bold;
        margin-top: 20px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <svg id="journey-circle" viewBox="0 0 800 800"></svg>
    </div>

    <div class="hover-tooltip" id="hover-tooltip">
      <div class="tooltip-icon-large" id="tooltip-icon-large">
        <img id="tooltip-icon-img" src="" alt="Stage Icon" />
      </div>
      <h3 id="tooltip-title"></h3>
      <div class="tooltip-meta">
        <span id="tooltip-number"></span>
      </div>
      <p id="tooltip-description"></p>
    </div>

    <!-- Story Selection Modal -->
    <div class="modal" id="story-modal">
      <div class="modal-content">
        <h2>Compare Stories to Campbell's Journey</h2>
        <p class="modal-subtitle">
          Campbell's Hero's Journey is always shown on the outer ring. Select up
          to 3 additional stories to compare.
        </p>
        <p class="selection-count">Select up to 3 stories</p>
        <div id="story-options"></div>
        <div class="modal-buttons">
          <button class="modal-button cancel" onclick="closeModal()">
            Cancel
          </button>
          <button class="modal-button apply" onclick="applySelection()">
            Apply
          </button>
        </div>
      </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
      <div class="loading-content">
        <div class="loading-spinner">
          <svg viewBox="0 0 100 100">
            <!-- Red arc (Departure) - 0° to 120° (top to bottom-right) -->
            <path
              d="M 50 10 A 40 40 0 0 1 84.64 70"
              fill="none"
              stroke="#e74c3c"
              stroke-width="8"
              stroke-linecap="round"
            />

            <!-- Blue arc (Initiation) - 120° to 240° (bottom-right to bottom-left) -->
            <path
              d="M 84.64 70 A 40 40 0 0 1 15.36 70"
              fill="none"
              stroke="#3498db"
              stroke-width="8"
              stroke-linecap="round"
            />

            <!-- Green arc (Return) - 240° to 360° (bottom-left to top) -->
            <path
              d="M 15.36 70 A 40 40 0 0 1 50 10"
              fill="none"
              stroke="#2ecc71"
              stroke-width="8"
              stroke-linecap="round"
            />
          </svg>
        </div>
        <div class="loading-text">Loading stages...</div>
      </div>
    </div>

    <script>
      let stagesData;
      const tooltip = document.getElementById("hover-tooltip");
      let currentTooltipTarget = null;
      const stageIcons = {};
      const loadedStoryData = {}; // Cache for loaded story data
      const storyIcons = {}; // Cache for story-specific icons
      let connectionLinesGroup = null; // Group for connection lines

      // Change the availableStories structure to include id
      const availableStories = [
        { id: "the_matrix", name: "The Matrix", folder: "the_matrix" },
        { id: "sister_act", name: "Sister Act", folder: "sister_act" },
        { id: "pig", name: "Pig", folder: "pig" },
      ];

      // Update the default selection to use the id
      // let selectedStories = ["the_matrix", "pig"];
      let selectedStories = [];

      // Load all stage icons for base (Campbell's)
      async function loadStageIcons() {
        const iconPromises = [];
        for (let i = 0; i <= 17; i++) {
          const paddedNum = i.toString().padStart(2, "0");
          iconPromises.push(
            fetch(`./content/base/icon_stage_${paddedNum}.html`)
              .then((response) => response.text())
              .then((html) => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, "text/html");
                const svgElement = doc.querySelector("svg");
                if (svgElement) {
                  stageIcons[i] = svgElement.innerHTML;
                }
              })
              .catch((error) =>
                console.error(`Error loading icon ${i}:`, error)
              )
          );
        }
        await Promise.all(iconPromises);
      }

      // Load icons for a specific story
      async function loadStoryIcons(storyFolder) {
        if (storyIcons[storyFolder]) {
          return storyIcons[storyFolder];
        }

        const icons = {};
        const iconPromises = [];

        for (let i = 0; i <= 17; i++) {
          const paddedNum = i.toString().padStart(2, "0");

          // Load thumbnail for small circles
          const thumbnailPromise = fetch(
            `./content/${storyFolder}/stage_${paddedNum}_thumbnail.png`
          )
            .then((response) => {
              if (!response.ok) {
                throw new Error("Thumbnail not found");
              }
              return response.blob();
            })
            .then((blob) => {
              const url = URL.createObjectURL(blob);
              if (!icons[i]) icons[i] = {};
              icons[i].thumbnail = url;
            })
            .catch((error) => {
              console.log(`Thumbnail ${i} not found for ${storyFolder}`);
            });

          // Load larger image for popup
          const imagePromise = fetch(
            `./content/${storyFolder}/stage_${paddedNum}_image.png`
          )
            .then((response) => {
              if (!response.ok) {
                throw new Error("Image not found");
              }
              return response.blob();
            })
            .then((blob) => {
              const url = URL.createObjectURL(blob);
              if (!icons[i]) icons[i] = {};
              icons[i].image = url;
            })
            .catch((error) => {
              console.log(`Image ${i} not found for ${storyFolder}`);
            });

          iconPromises.push(thumbnailPromise, imagePromise);
        }

        await Promise.all(iconPromises);
        storyIcons[storyFolder] = icons;
        return icons;
      }

      // Load story data from JSON
      async function loadStoryData(storyFolder) {
        if (loadedStoryData[storyFolder]) {
          return loadedStoryData[storyFolder];
        }

        try {
          const response = await fetch(`./content/${storyFolder}/stages.json`);
          const data = await response.json();
          loadedStoryData[storyFolder] = data;
          return data;
        } catch (error) {
          console.error(`Error loading story data for ${storyFolder}:`, error);
          return null;
        }
      }

      // Load the stages data
      async function initialize() {
        showLoading(); // Show loading indicator
        await loadStageIcons();
        const response = await fetch("./content/base/stages.json");
        const data = await response.json();
        stagesData = data.heroic_journey;

        // Load default selected stories data and icons
        for (const storyId of selectedStories) {
          const story = availableStories.find((s) => s.id === storyId);
          if (story) {
            await loadStoryData(story.folder);
            await loadStoryIcons(story.folder);
          }
        }

        createCircle();
        populateStoryOptions();
        updateCenterText();
        hideLoading(); // Hide loading indicator
      }

      initialize().catch((error) =>
        console.error("Error initializing:", error)
      );

      function populateStoryOptions() {
        const container = document.getElementById("story-options");
        container.innerHTML = "";

        availableStories.forEach((story) => {
          const option = document.createElement("div");
          option.className = "story-option";
          if (selectedStories.includes(story.id)) {
            option.classList.add("selected");
          }

          option.innerHTML = `
            <div class="story-checkbox"></div>
            <div class="story-name">${story.name}</div>
          `;

          option.onclick = () => toggleStorySelection(story.id, option);
          container.appendChild(option);
        });
      }

      function toggleStorySelection(storyId, element) {
        if (selectedStories.includes(storyId)) {
          // User is deselecting a story
          selectedStories = selectedStories.filter((id) => id !== storyId);
          element.classList.remove("selected");
        } else {
          // User is selecting a story
          if (selectedStories.length >= 3) {
            // Remove the first (oldest) selected story
            const oldestStoryId = selectedStories.shift();

            // Find and update the UI for the deselected story
            const storyOptions = document.querySelectorAll(".story-option");
            storyOptions.forEach((option) => {
              const storyName = option.querySelector(".story-name").textContent;
              const story = availableStories.find((s) => s.name === storyName);
              if (story && story.id === oldestStoryId) {
                option.classList.remove("selected");
              }
            });
          }

          // Add the new selection
          selectedStories.push(storyId);
          element.classList.add("selected");
        }
      }

      function openModal() {
        document.getElementById("story-modal").classList.add("visible");
        populateStoryOptions();
      }

      function closeModal() {
        document.getElementById("story-modal").classList.remove("visible");
      }

      function showLoading() {
        document.getElementById("loading-overlay").classList.add("visible");
      }

      function hideLoading() {
        document.getElementById("loading-overlay").classList.remove("visible");
      }

      async function applySelection() {
        showLoading(); // Show loading indicator
        closeModal();

        // Load all selected story data and icons
        const loadPromises = selectedStories.map(async (storyId) => {
          const story = availableStories.find((s) => s.id === storyId);
          await loadStoryData(story.folder);
          await loadStoryIcons(story.folder);
        });

        await Promise.all(loadPromises);

        // Redraw the circle with all stories
        await createCircle();
        updateCenterText();

        hideLoading(); // Hide loading indicator
      }

      function updateCenterText() {
        const centerTextElements = document.querySelectorAll(".center-text");
        if (selectedStories.length === 0) {
          centerTextElements[0].textContent = "Click to Compare";
          centerTextElements[1].textContent = "Stories";
        } else if (selectedStories.length === 1) {
          const story = availableStories.find(
            (s) => s.id === selectedStories[0]
          );
          centerTextElements[0].textContent = "Comparing:";
          centerTextElements[1].textContent = story.name;
        } else {
          centerTextElements[0].textContent = "Comparing";
          centerTextElements[1].textContent = `${selectedStories.length} Stories`;
        }
      }

      function showConnectionLines(stageIndex) {
        if (selectedStories.length === 0 || !connectionLinesGroup) return;

        // First, ensure all lines show their base state (grey)
        const allLines =
          connectionLinesGroup.querySelectorAll(".connection-line");
        allLines.forEach((line) => {
          line.classList.remove("visible");
        });

        // Then highlight the lines for the hovered stage (yellow and thicker)
        const lines = connectionLinesGroup.querySelectorAll(
          `.connection-line[data-stage="${stageIndex}"]`
        );
        lines.forEach((line) => line.classList.add("visible"));
      }

      function hideConnectionLines() {
        if (!connectionLinesGroup) return;

        // Remove the highlighted (yellow) state, keeping grey lines visible
        const allLines =
          connectionLinesGroup.querySelectorAll(".connection-line");
        allLines.forEach((line) => line.classList.remove("visible"));
      }

      async function createCircle() {
        const svg = document.getElementById("journey-circle");
        svg.innerHTML = ""; // Clear existing content

        const centerX = 400;
        const centerY = 400;

        // Define concentric circle layout
        const stageRadius = 28; // Circle size
        const ringGap = 70; // Space between rings

        // Ring radii - working from outside in
        const outerRadius = 360; // Outermost ring (Campbell - always shown)
        const ring2Radius = outerRadius - ringGap; // 290
        const ring3Radius = ring2Radius - ringGap; // 220
        const ring4Radius = ring3Radius - ringGap; // 150

        const centerCircleRadius = 80; // Center circle

        // Act colors
        const actColors = [
          "#e74c3c", // Departure - Red
          "#3498db", // Initiation - Blue
          "#2ecc71", // Return - Green
        ];

        // Story-specific colors for inner rings
        const storyColors = [
          "#9b59b6", // Purple
          "#f39c12", // Orange
          "#1abc9c", // Teal
        ];

        // --- Arrowhead marker (for curved arrows) ---
        const defs = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "defs"
        );
        const marker = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "marker"
        );
        marker.setAttribute("id", "arrowhead");
        marker.setAttribute("viewBox", "0 0 10 10");
        marker.setAttribute("refX", "9");
        marker.setAttribute("refY", "5");
        marker.setAttribute("markerWidth", "5");
        marker.setAttribute("markerHeight", "5");
        marker.setAttribute("orient", "auto");
        const markerPath = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        markerPath.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
        markerPath.setAttribute("fill", "#666");
        marker.appendChild(markerPath);
        defs.appendChild(marker);
        svg.appendChild(defs);
        // --- end marker ---

        // Create connection lines group (before other elements so lines appear behind)
        connectionLinesGroup = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );
        connectionLinesGroup.classList.add("connection-lines");
        svg.appendChild(connectionLinesGroup);

        // Draw center circle (clickable)
        const centerCircle = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle"
        );
        centerCircle.setAttribute("cx", centerX);
        centerCircle.setAttribute("cy", centerY);
        centerCircle.setAttribute("r", centerCircleRadius);
        centerCircle.classList.add("center-circle");
        centerCircle.onclick = openModal;
        svg.appendChild(centerCircle);

        const centerText = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        centerText.setAttribute("x", centerX);
        centerText.setAttribute("y", centerY - 5);
        centerText.classList.add("center-text");
        centerText.textContent = "Click to Compare";
        svg.appendChild(centerText);

        const centerText2 = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "text"
        );
        centerText2.setAttribute("x", centerX);
        centerText2.setAttribute("y", centerY + 15);
        centerText2.classList.add("center-text");
        centerText2.textContent = "Stories";
        svg.appendChild(centerText2);

        // Collect all stages with their act info (Campbell's base)
        const allStages = [];
        stagesData.acts.forEach((act) => {
          act.stages.forEach((stage) => {
            allStages.push({
              ...stage,
              actName: act.act_name,
              actNumber: act.act_number,
              actColor: actColors[act.act_number - 1],
            });
          });
        });

        const totalStages = allStages.length;
        const angleStep = (2 * Math.PI) / totalStages;
        const startAngle = -Math.PI / 2; // Start at top

        // Draw act segments on outermost ring
        let currentAngle = startAngle;
        stagesData.acts.forEach((act) => {
          const stageCount = act.stages.length;
          const segmentAngle = angleStep * stageCount;

          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          const startX = centerX + outerRadius * Math.cos(currentAngle);
          const startY = centerY + outerRadius * Math.sin(currentAngle);
          const endAngle = currentAngle + segmentAngle;
          const endX = centerX + outerRadius * Math.cos(endAngle);
          const endY = centerY + outerRadius * Math.sin(endAngle);

          const largeArc = segmentAngle > Math.PI ? 1 : 0;

          path.setAttribute(
            "d",
            `M ${startX} ${startY} A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${endX} ${endY}`
          );
          path.classList.add("act-segment");
          path.setAttribute("stroke", actColors[act.act_number - 1]);

          // Add hover/click events for act segments
          const actData = {
            type: "act",
            name: act.act_name,
            number: act.act_number,
            stageCount: stageCount,
            color: actColors[act.act_number - 1],
          };

          path.addEventListener("mouseenter", (e) =>
            showActTooltip(e, actData)
          );
          path.addEventListener("mousemove", (e) => updateTooltipPosition(e));
          path.addEventListener("mouseleave", hideTooltip);

          path.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (currentTooltipTarget === actData) {
              hideTooltip();
            } else {
              showActTooltip(e.touches[0], actData);
            }
          });

          svg.appendChild(path);

          currentAngle = endAngle;
        });

        // --- 18 Curved clockwise arrows, one between each stage ---
        const arrowRadius = outerRadius - stageRadius - 12;
        const arrowsGroup = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "g"
        );
        arrowsGroup.setAttribute("class", "direction-arrows");

        const gapFactor = 0.2;
        const spanFactor = 0.6;

        for (let i = 0; i < totalStages; i++) {
          const segmentStart = startAngle + angleStep * i;

          const a1 = segmentStart + angleStep * gapFactor;
          const a2 = a1 + angleStep * spanFactor;

          const x1 = centerX + arrowRadius * Math.cos(a1);
          const y1 = centerY + arrowRadius * Math.sin(a1);
          const x2 = centerX + arrowRadius * Math.cos(a2);
          const y2 = centerY + arrowRadius * Math.sin(a2);

          const arrowPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          arrowPath.setAttribute(
            "d",
            `M ${x1} ${y1} A ${arrowRadius} ${arrowRadius} 0 0 1 ${x2} ${y2}`
          );
          arrowPath.setAttribute("class", "circle-arrow");
          arrowPath.setAttribute("marker-end", "url(#arrowhead)");
          arrowsGroup.appendChild(arrowPath);
        }

        svg.appendChild(arrowsGroup);
        // --- end arrows ---

        // Store stage positions for connection lines
        const stagePositions = [];

        // Draw Campbell's stages on outermost ring
        allStages.forEach((stage, index) => {
          const angle = startAngle + angleStep * index;
          const x = centerX + outerRadius * Math.cos(angle);
          const y = centerY + outerRadius * Math.sin(angle);

          stagePositions[index] = [{ x, y, radius: outerRadius }];

          const group = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          group.classList.add("stage");
          group.setAttribute("data-index", index);
          group.setAttribute("data-ring", "base");

          // Background circle
          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("cx", x);
          circle.setAttribute("cy", y);
          circle.setAttribute("r", stageRadius);
          circle.classList.add("stage-bg");
          // Remove or don't set stroke attribute here for base stages
          group.appendChild(circle);

          // Add clip path for circular icon
          const clipPathId = `clip-base-${index}`;
          const clipPath = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "clipPath"
          );
          clipPath.setAttribute("id", clipPathId);
          const clipCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          clipCircle.setAttribute("cx", x);
          clipCircle.setAttribute("cy", y);
          clipCircle.setAttribute("r", stageRadius - 2);
          clipPath.appendChild(clipCircle);
          svg.appendChild(clipPath);

          // Add icon if available
          if (stageIcons[stage.stage_number]) {
            const iconGroup = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            iconGroup.classList.add("stage-icon");
            iconGroup.setAttribute("clip-path", `url(#${clipPathId})`);

            const iconSize = stageRadius * 1.6;
            const iconX = x - iconSize / 2;
            const iconY = y - iconSize / 2;

            iconGroup.innerHTML = `<g transform="translate(${iconX}, ${iconY}) scale(${
              iconSize / 100
            })">
              ${stageIcons[stage.stage_number]}
            </g>`;

            group.appendChild(iconGroup);
          }

          // Mouse events for hover tooltip (desktop)
          const stageData = {
            ...stage,
            storyName: "Campbell's Hero's Journey",
            iconType: null, // Campbell stages don't show large icons
          };

          group.addEventListener("mouseenter", (e) => {
            showStageTooltip(e, stageData);
            showConnectionLines(index);
          });
          group.addEventListener("mousemove", (e) => updateTooltipPosition(e));
          group.addEventListener("mouseleave", (e) => {
            hideTooltip();
            hideConnectionLines();
          });

          // Touch events for mobile
          group.addEventListener("touchstart", (e) => {
            e.preventDefault();
            if (currentTooltipTarget === stageData) {
              hideTooltip();
              hideConnectionLines();
            } else {
              showStageTooltip(e.touches[0], stageData);
              showConnectionLines(index);
            }
          });

          svg.appendChild(group);
        });

        // Draw inner rings for selected stories
        const ringRadii = [ring2Radius, ring3Radius, ring4Radius];

        for (let i = 0; i < selectedStories.length; i++) {
          const storyId = selectedStories[i];
          const story = availableStories.find((s) => s.id === storyId);
          const storyData = loadedStoryData[story.folder];
          const icons = storyIcons[story.folder] || {};

          if (!storyData) continue;

          const ringRadius = ringRadii[i];
          const storyColor = storyColors[i];

          // Draw story stages
          storyData.forEach((stageData, index) => {
            const angle = startAngle + angleStep * index;
            const x = centerX + ringRadius * Math.cos(angle);
            const y = centerY + ringRadius * Math.sin(angle);

            // Store position for connection lines
            if (!stagePositions[index]) {
              stagePositions[index] = [];
            }
            stagePositions[index].push({ x, y, radius: ringRadius });

            const group = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            group.classList.add("stage");
            group.setAttribute("data-story", storyId);
            group.setAttribute("data-index", index);
            group.setAttribute("data-ring", i + 1);

            // Background circle
            const circle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            circle.setAttribute("cx", x);
            circle.setAttribute("cy", y);
            circle.setAttribute("r", stageRadius * 0.85); // Slightly smaller for inner rings
            circle.classList.add("stage-bg");
            circle.setAttribute("fill", "white");
            circle.setAttribute("stroke", storyColor);
            group.appendChild(circle);

            // Add clip path for circular icon
            const clipPathId = `clip-${storyId}-${index}`;
            const clipPath = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "clipPath"
            );
            clipPath.setAttribute("id", clipPathId);
            const clipCircle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            clipCircle.setAttribute("cx", x);
            clipCircle.setAttribute("cy", y);
            clipCircle.setAttribute("r", stageRadius * 0.85 - 2);
            clipPath.appendChild(clipCircle);
            svg.appendChild(clipPath);

            // Add PNG icon if available, otherwise show stage number
            if (
              icons[stageData.stage_number] &&
              icons[stageData.stage_number].thumbnail
            ) {
              const iconImage = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "image"
              );

              const iconSize = stageRadius * 0.85 * 2;
              const iconX = x - iconSize / 2;
              const iconY = y - iconSize / 2;

              iconImage.setAttribute(
                "href",
                icons[stageData.stage_number].thumbnail
              );
              iconImage.setAttribute("x", iconX);
              iconImage.setAttribute("y", iconY);
              iconImage.setAttribute("width", iconSize);
              iconImage.setAttribute("height", iconSize);
              iconImage.setAttribute("clip-path", `url(#${clipPathId})`);
              iconImage.classList.add("stage-icon");

              group.appendChild(iconImage);
            } else {
              // Fallback to stage number if no icon
              const stageText = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "text"
              );
              stageText.setAttribute("x", x);
              stageText.setAttribute("y", y);
              stageText.textContent = stageData.stage_number;
              group.appendChild(stageText);
            }

            // Mouse events for hover tooltip
            // Get the corresponding Campbell stage name
            const campbellStage = allStages[index];
            const tooltipData = {
              name: stageData.title || campbellStage.name, // Use story's title if available, otherwise Campbell's name
              description: stageData.description,
              stage_number: stageData.stage_number,
              storyName: story.name,
              actName: campbellStage.actName,
              campbellStageName: campbellStage.name, // Add Campbell's stage name
              time: stageData.time, // Add timestamp
              iconType: icons[stageData.stage_number] ? "png" : null,
              iconUrl: icons[stageData.stage_number]?.image || null,
            };

            group.addEventListener("mouseenter", (e) => {
              showStageTooltip(e, tooltipData);
              showConnectionLines(index);
            });
            group.addEventListener("mousemove", (e) =>
              updateTooltipPosition(e)
            );
            group.addEventListener("mouseleave", (e) => {
              hideTooltip();
              hideConnectionLines();
            });

            group.addEventListener("touchstart", (e) => {
              e.preventDefault();
              if (currentTooltipTarget === tooltipData) {
                hideTooltip();
                hideConnectionLines();
              } else {
                showStageTooltip(e.touches[0], tooltipData);
                showConnectionLines(index);
              }
            });

            svg.appendChild(group);
          });
        }

        // Create connection lines between stages
        if (selectedStories.length > 0) {
          stagePositions.forEach((positions, stageIndex) => {
            if (positions.length > 1) {
              // Draw lines connecting all rings for this stage
              for (let i = 0; i < positions.length - 1; i++) {
                const line = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "line"
                );
                line.setAttribute("x1", positions[i].x);
                line.setAttribute("y1", positions[i].y);
                line.setAttribute("x2", positions[i + 1].x);
                line.setAttribute("y2", positions[i + 1].y);
                line.classList.add("connection-line");
                line.setAttribute("data-stage", stageIndex);
                connectionLinesGroup.appendChild(line);
              }
            }
          });
        }
      }

      function showStageTooltip(event, stage) {
        currentTooltipTarget = stage;

        // Update title and text content
        document.getElementById("tooltip-title").textContent =
          stage.name || `Stage ${stage.stage_number}`;

        let metaText = `Stage ${stage.stage_number}`;
        if (stage.campbellStageName) {
          // For story stages, show Campbell's base stage name
          metaText += ` | ${stage.campbellStageName}`;
        } else if (stage.actName) {
          // For Campbell's stages, show act name
          metaText += ` | ${stage.actName}`;
        }
        if (stage.storyName) {
          metaText = `${stage.storyName} - ${metaText}`;
        }

        // Add timestamp if available
        if (stage.time) {
          metaText += ` | ${stage.time}`;
        }

        document.getElementById("tooltip-number").textContent = metaText;
        document.getElementById("tooltip-description").textContent =
          stage.description;

        // Handle large icon display for story stages only
        const iconContainer = document.getElementById("tooltip-icon-large");
        const iconImg = document.getElementById("tooltip-icon-img");

        if (stage.iconType === "png" && stage.iconUrl) {
          // Show large PNG image for story stages
          iconImg.src = stage.iconUrl;
          iconImg.alt = stage.name;
          iconContainer.classList.add("visible");
        } else {
          // Hide large icon for Campbell's base stages
          iconContainer.classList.remove("visible");
        }

        tooltip.classList.add("visible");
        updateTooltipPosition(event);
      }

      function showActTooltip(event, actData) {
        currentTooltipTarget = actData;

        // Hide large icon for act tooltips
        document
          .getElementById("tooltip-icon-large")
          .classList.remove("visible");

        document.getElementById("tooltip-title").textContent = actData.name;
        document.getElementById(
          "tooltip-number"
        ).textContent = `Act ${actData.number} | ${actData.stageCount} Stages`;

        // Generate description based on act
        let description = "";
        if (actData.number === 1) {
          description =
            "The hero is called from their ordinary world to embark on an adventure. They initially refuse but eventually cross the threshold into the unknown.";
        } else if (actData.number === 2) {
          description =
            "The hero faces tests and trials, meets allies and enemies, and ultimately achieves their goal through transformation and understanding.";
        } else if (actData.number === 3) {
          description =
            "Having achieved the goal, the hero must return to the ordinary world, integrating their new wisdom and mastering both worlds.";
        }

        document.getElementById("tooltip-description").textContent =
          description;

        tooltip.classList.add("visible");
        updateTooltipPosition(event);
      }

      function updateTooltipPosition(event) {
        // On mobile (touch devices), center the tooltip
        if (window.innerWidth <= 768 || event.type === "touchstart") {
          // Position will be handled by CSS (centered)
          return;
        }

        // Desktop positioning
        const offset = 15;
        const tooltipRect = tooltip.getBoundingClientRect();

        let x = event.clientX + offset;
        let y = event.clientY + offset;

        // Prevent tooltip from going off-screen horizontally
        if (x + tooltipRect.width > window.innerWidth) {
          x = event.clientX - tooltipRect.width - offset;
        }

        // If it would still go off the left edge, clamp it
        if (x < 0) {
          x = offset;
        }

        // Prevent tooltip from going off-screen vertically
        if (y + tooltipRect.height > window.innerHeight) {
          y = event.clientY - tooltipRect.height - offset;
        }

        // If it would still go off the top edge, clamp it
        if (y < 0) {
          y = offset;
        }

        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";
        tooltip.style.transform = "none";
      }

      function hideTooltip() {
        currentTooltipTarget = null;
        tooltip.classList.remove("visible");
        // Hide large icon when tooltip closes
        document
          .getElementById("tooltip-icon-large")
          .classList.remove("visible");
      }

      // Hide tooltip when clicking/touching outside
      document.addEventListener("click", (e) => {
        if (!e.target.closest(".stage") && !e.target.closest(".act-segment")) {
          hideTooltip();
          hideConnectionLines();
        }
      });

      document.addEventListener("touchstart", (e) => {
        if (!e.target.closest(".stage") && !e.target.closest(".act-segment")) {
          hideTooltip();
          hideConnectionLines();
        }
      });
    </script>
  </body>
</html>
